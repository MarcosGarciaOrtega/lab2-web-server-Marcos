# Lab 2 Web Server -- Project Report

## Description of Changes
The first step I took was to create a custom error page. This page is displayed by the spring boot application when it encounters an error. The file was named error.html and was placed in src/main/resources/templates directory. Then I implemented a test to verify that the error page was being displayed correctly.
The second feature I added was a new endpoint that returns the current server time (/time). The endpoint returns the time in json format.
```json
{"time": "2024-06-15T14:30:00Z"}
```
I also implemented a test to verify that the endpoint was working correctly.

The last change I made was to enable HTTP/2 and SSL support in the application. To do this I generated a self-signed certificate and configured the application to use it. To create the self-signed certificate I used openssl, next I used openssl again to create a pkcs12 keystore. Finally I configured the application with the application.yml to enable SSL and HTTP/2:
```yaml
server:
    port: 8443
    ssl:
        enabled: true
        key-store: classpath:localhost.p12
        key-store-password: "secret" # Use the same export password you set when creating the PKCS#12 file
        key-store-type: PKCS12
    http2:
        enabled: true
```

---

## Technical Decisions
The test that was implemented to check if the error page works correctly was made as an integration test. This test says that it accepts html content:
```kotlin
headers.accept = listOf(MediaType.TEXT_HTML)
```
The test checks if the status is 404 Not Found and if the body contains the text "¡Oops! Página no encontrada" which appears on the error page.
```kotlin
assertThat(response.statusCode).isEqualTo(HttpStatus.NOT_FOUND)
assertThat(response.body).contains("¡Oops! Página no encontrada")
```
To create the new endpoint that returns the current server time, I created a new rest controller named TimeController. This rest controller has one endpoint that handles GET requests to /time and returns a TimeDTO. I use a service to separate the logic of getting the time from the controller. The service implements the TimeProvider interface.
```kotlin
data class TimeDTO(val time: LocalDateTime)

interface TimeProvider {
    fun now(): LocalDateTime
}

@Service
class TimeService : TimeProvider {
    override fun now(): LocalDateTime = LocalDateTime.now()
}

fun LocalDateTime.toDTO(): TimeDTO = TimeDTO(time = this)

@RestController
class TimeController(private val service: TimeProvider) {
    @GetMapping("/time")
    fun time(): TimeDTO = service.now().toDTO()
}
```
The test I added to verify that the endpoint was working correctly do a GET request to /time and checks if the status is 200 OK and if the body contains a date that is before or equal to the current date.

For the last part I follow the instructions given in the lab to generate a self-signed certificate and create a pkcs12 keystore. There was no technical decision to make.

---

## Learning Outcomes
In this practice I have learned how to serve a custom error page in a spring boot application. I have also learned how to create a new endpoint in a app and do it following good practices like using interfaces and services and separating the logic from the controller. Finally I have learned how to create a self-signed certificate and configure a spring boot application to use it to enable SSL and HTTP/2.

---

## AI Disclosure
### AI Tools Used
- ChatGPT
- GitHub Copilot

### AI-Assisted Work
- The whole error page was generated by chatGPT, also some errors like getting only html for a request were fixed with chatGPT help and copilot helped me with some suggestions in the report.
- Percentage done with AI assistance: 30%, percentage done without AI assistance: 70%
- I did not modify the html because it was not necessary.

### Original Work
- Both of the tests were planned and written by me without taking into account the error previously mentioned, also the certificate and the application.yml.
- I read each part before doing it to understand the task I had to do, also I discussed with my classmates to understand better some concepts. Then I did the task and check if it works. When the task was done I analyzed what I have done to understand it better.